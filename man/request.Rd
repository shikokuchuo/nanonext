% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/context.R
\name{request}
\alias{request}
\alias{request_signal}
\title{Request over Context (RPC Client for Req/Rep Protocol)}
\usage{
request(
  context,
  data,
  send_mode = c("serial", "raw"),
  recv_mode = c("serial", "character", "complex", "double", "integer", "logical",
    "numeric", "raw"),
  timeout = NULL,
  keep.raw = FALSE
)

request_signal(
  context,
  data,
  send_mode = c("serial", "raw"),
  recv_mode = c("serial", "character", "complex", "double", "integer", "logical",
    "numeric", "raw"),
  timeout = NULL,
  keep.raw = FALSE,
  cv
)
}
\arguments{
\item{context}{a Context.}

\item{data}{an object (if send_mode = 'raw', a vector).}

\item{send_mode}{[default 'serial'] whether data will be sent serialized or
as a raw vector. Use 'serial' for sending and receiving within R to ensure
perfect reproducibility. Use 'raw' for sending vectors of any type
(converted to a raw byte vector for sending) - essential when interfacing
with external applications. Alternatively, for performance, specify an
integer position in the vector of choices i.e. 1L for 'serial' or 2L for
'raw'.}

\item{recv_mode}{[default 'serial'] mode of vector to be received - one of
'serial', 'character', 'complex', 'double', 'integer', 'logical',
'numeric', or 'raw'. The default 'serial' means a serialised R object,
for the other modes, the raw vector received will be converted into the
respective mode. Alternatively, for performance, specify an integer
position in the vector of choices e.g. 1L for 'serial', 2L for 'character'
etc.}

\item{timeout}{[default NULL] integer value in milliseconds or NULL, which
applies a socket-specific default, usually the same as no timeout. The
context must have created with \code{context(verify = TRUE)}, or else
this value will be ignored.}

\item{keep.raw}{[default FALSE] logical flag whether to keep and return the
received raw vector along with the converted data. Supplying a non-logical
value will error.}

\item{cv}{\strong{For the signalling version}: a 'conditionVariable' that
should be signalled when the async receive is complete.}
}
\value{
A 'recvAio' (object of class 'recvAio') (invisibly).
}
\description{
Implements a caller/client for the req node of the req/rep protocol. Sends
    data to the rep node (executor/server) and returns an Aio, which can be
    called for the value when required.

A signalling version of the function takes a 'conditionVariable' as an
    additional argument and signals it when the async receive is complete.
}
\details{
Sending the request and receiving the result are both performed async,
    hence the function will return immediately with a 'recvAio' object. Access
    the return value at \code{$data}.

    This is designed so that the process on the server can run concurrently
    without blocking the client.

    Optionally use \code{\link{call_aio}} on the 'recvAio' to call (and wait
    for) the result.

    If an error occured in the server process, a nul byte \code{00} will be
    received (as \code{$data} if 'recv_mode' = 'serial', as \code{$raw}
    otherwise). This allows an error to be easily distinguished from a NULL
    return value. \code{\link{is_nul_byte}} can be used to test for a nul byte.

    The value for 'timeout' is valid only when using a verified context
    created with \code{context(verify = TRUE)}, and ignored otherwise. This
    is as it is an error to specify a timeout without there being an existing
    connection.

\strong{For the signalling version}: when the receive is complete,
    the supplied 'conditionVariable' is signalled by incrementing its value
    by 1. This happens asynchronously and independently of the R execution
    thread.
}
\examples{
req <- socket("req", listen = "tcp://127.0.0.1:6546")
rep <- socket("rep", dial = "tcp://127.0.0.1:6546")

ctxq <- context(req)
ctxp <- context(rep)

# works if req and rep are running in parallel in different processes
reply(ctxp, execute = function(x) x + 1, timeout = 50)
aio <- request(ctxq, data = 2022)
aio$data

close(req)
close(rep)

# Signalling a condition variable

req <- socket("req", listen = "tcp://127.0.0.1:6546")
ctxq <- context(req)
cv <- cv()
aio <- request_signal(ctxq, data = 2022, cv = cv)
until(cv, 10L)
close(req)

# The following should be run in another process
# rep <- socket("rep", dial = "tcp://127.0.0.1:6546")
# ctxp <- context(rep)
# reply(ctxp, execute = function(x) x + 1)
# close(rep)

}
